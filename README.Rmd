---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# R7

<!-- badges: start -->

[![R-CMD-check](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml) [![Codecov test coverage](https://codecov.io/gh/RConsortium/OOP-WG/branch/master/graph/badge.svg)](https://codecov.io/gh/RConsortium/OOP-WG?branch=master)

<!-- badges: end -->

The R7 package is a new OOP system designed to be a successor to S3 and S4.
It it is designed and implemented collaboratively by the RConsortium Object-oriented Programming Working Group, which includes representatives from R-Core, BioConductor, RStudio/tidyverse, and the wider R community.

## Installation

The long-term goal of this project is to merge R7 in to base R.
For now, you can experiment with the development version from GitHub:

```{r, eval = FALSE}
# install.packages("remotes")
remotes::install_github("r-consortium/OOP-WG")
```

## Usage

```{r}
library(R7)
```

R7 classes have a formal definition, which includes a list of properties and an optional validator.
You create a class with `new_class()`:

```{r}
range <- new_class("range",
  properties = list(
    start = double, 
    end = double
  ),
  validator = function(self) {
    if (length(self@start) != 1) {
      "@start must be length 1"
    } else if (length(self@end) != 1) {
      "@end must be length 1"
    } else if (self@end < self@start) {
      "@end must be greater than or equal to @start"
    }
  }
)
```

`new_class()` returns the class object, a constructor which you can use to create objects that are instances of that class:

```{r}
x <- range(start = 1, end = 10)
x
```

R7 objects use `@` to get and set properties:

```{r}
x@start
x@end <- 20
x
```

Properties are automatically validated against their type and with the class validator:

```{r, error = TRUE}
x@end <- "x"
x@end <- -1
```

Generics are defined by `new_generic()`.
The first argument is the generic name (used in error messages) and the second defines the arguments that will be used for dispatch.
The third, and optional argument, supplies the body of the generic.
This is only needed if your generic has additional arguments that aren't used for dispatch.

```{r}
inside <- new_generic("inside", "x", function(x, y) {
  # Actually finds and calls the appropriate method
  method_call()
})
# Add a method for our class
method(inside, range) <- function(x, y) {
  y >= x@start & y <= x@end
}
inside

inside(x, c(0, 5, 10, 15))
```

R7 generics support a limited form of multiple dispatch; see `vignette("dispatch")` for details.

You can also use `method<-` to register methods for R7 objects on S3 or S4 generics:

```{r}
method(format, range) <- function(x, ...) {
  paste0("[", x@start, ", ", x@end, "]")
}
format(x)

method(mean, range) <- function(x, ...) {
  (x@start + x@end) / 2
}
mean(x)
```

Learn more in `vignettte("R7")`.
