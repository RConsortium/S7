---
title: "Introducing R7"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introducing R7}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

R7 is a new OO system for R that is designed to take the best parts of S3 and S4.

```{r setup}
library(R7)
```

## Basics

We'll start with an quick overview of the most important parts of R7: classes and object, generics and methods, and the basics of method dispatch and inheritance.

### Classes and objects

R7 classes have a formal definition that you create with `new_class()`.
There are two arguments that you'll use with almost every class:

-   The `name`, of the class, supplied in the first argument.
-   The class `properties`, which is the data associated with each instance of each instance of the class. The easiest way to define properties is to supply a named list where the values define the valid types of the property.

The following code defines a simple `pet` class with two properties: a character `name` and a double `age`.

```{r}
dog <- new_class("dog", properties = list(
  name = character,
  age = double
))
dog
```

Note that I've assigned the return value of `new_class()` to an object with the same name as the class.
This is important because that object represents the class and is what you use to construct instances of the class:

```{r}
lola <- dog(name = "Lola", age = 11)
lola
```

Once you have an R7 object, you can get and set properties using `@`:

```{r}
lola@age <- 11
lola@age
```

And R7 automatically validates the type of the property:

```{r, error = TRUE}
lola@age <- "twelve"
```

### Generics and methods

A function that behaves differently depending on the class of its inputs is called a **generic**.
It's simple to create a basic generic with R7: you just need to supply the name of the generic (used in error messages) and the name of the argument it should use to find the method:

```{r}
speak <- new_generic("speak", "x")
```

Like with `new_class()`, you should always assign the result of `new_generic()` to an variable of the same name.

You register methods with `method<-`:

```{r}
method(speak, dog) <- function(x) {
  "Woof"
}
```

Once you've register a method, you can use an object of that class with the generic:

```{r}
speak(lola)
```

We could define another class, and add another method to the generic:

```{r}
cat <- new_class("cat", properties = list(
  name = character,
  age = double
))
method(speak, cat) <- function(x) {
  "Meow"
}

fluffy <- cat(name = "Fluffy", age = 5)
speak(fluffy)
```

If you call the generic with a class that isn't registered, you'll get an error:

```{r, error = TRUE}
speak(1)
```

### Method dispatch and inheritance

The `cat` and `dog` classes share the same properties, so we could use a common parent class to extract out the duplicated specification.
Now we use the second argument to `new_class` to define a `parent`:

```{r}
pet <- new_class("pet", properties = list(
  name = character,
  age = double
)) 
cat <- new_class("cat", pet)
dog <- new_class("dog", pet)

cat
```

Method dispatch takes advantage of the hierarchy of parent classes: if a method is not defined for a class, it will next try the parent class:

```{r}
describe <- new_generic("describe", "x")
method(describe, pet) <- function(x) {
  paste0(x@name, " is ", x@age, " years old")
}
method(describe, dog) <- function(x) {
  paste0(x@name, " is a ", x@age, " year old dog")
}

lola <- dog(name = "Lola", age = 11)
fluffy <- cat(name = "Fluffy", age = 5)

describe(lola)
describe(fluffy)
```

R7 generics can do multiple dispatch; see `vignette("dispatch")` for details.

## Validation

R7 classes can have an optional `validator` that checks that the values of the properties:

```{r}
range <- new_class("range",
  properties = list(
    start = "numeric",
    end = "numeric"
  ),
  validator = function(self) {
    if (length(self@start) != 1) {
      "@start must be length 1"
    } else if (length(self@end) != 1) {
      "@end must be length 1"
    } else if (self@end < self@start) {
      sprintf(
        "@end (%i) must be greater than or equal to @start (%i)",
        self@end,
        self@start
      )
    }
  }
)
```

A `validator` is a function that takes an object (called `self`) that either returns `NULL` if it's valid or returns a character vector listing the reasons that it's not valid.
Typically you can construct it as a series of `if`-`else` statements.
The order of these statements is important.
In the example above, we can't do `self@end < self@start` before we've checked that `@start` and `@end` are the correct length.

Objects are validated automatically when constructed and when any property is modified:

```{r, error = TRUE}
x <- range(1, 2:3)
x <- range(10, 1)

x <- range(1, 10)
x@start <- 20
```

You can also manually `validate()` an object if you use a low-level R function to modify the object directly:

```{r, error = TRUE}
x <- range(1, 2)
attr(x, "start") <- 3
validate(x)
```

Imagine you wanted to write a function that would shift a property to the left or the right:

```{r}
shift <- function(x, shift) {
  x@start <- x@start + shift
  x@end <- x@end + shift
  x
}
shift(range(1, 10), 1)
```

There's a problem if `shift` is larger than `@end` - `@start`:

```{r, error = TRUE}
shift(range(1, 10), 10)
```

While the end result of `shift()` will be valid, an intermediate state is not.
The easiest way to resolve this problem is to set the properties all at once:

```{r}
shift <- function(x, shift) {
  props(x) <- list(
    start = x@start + shift,
    end = x@end + shift
  )
  x
}
shift(range(1, 10), 10)
```

The object is still validated, but it's only validated once, after all the properties have been modified.

## Properties

So far we've focused on the simplest form of property specification where you use a named list to supply the desired type for each property.
You can also use a more complex form with `new_property()`.
It allows you to define a define value or

### Default value

### Computed properties

```{r}
range <- new_class("range",
  properties = list(
    start = "numeric",
    end = "numeric",
    new_property(
      name = "length",
      getter = function(self) self@end - self@start,
    )
  )
)

range(start = 1, end = 10)
```

### Dynamic properties

By default, a property with a `getter` is read-only.
You can make it read-write by supplying a `settor`.
For example, we could extend the previous example to allow the `@length` to be set, by modifying the `@end` of the vector:

```{r}
range <- new_class("range",
  properties = list(
    start = "numeric",
    end = "numeric",
    new_property(
      name = "length",
      class = "numeric",
      getter = function(self) self@end - self@start,
      setter = function(self, value) {
        self@end <- self@start + value
        self
      }
    )
  )
)

x <- range(start = 1, end = 10)
x

x@length <- 5
x
```

## Introspection

Objects:

-   `R7_class()` returns the class object associated with an R7 object.

Classes:

-   `class@parent` gives the superclass.

Properties:

-   `prop_names(x)` gives character of property names.
-   `props(x)` gets all properties as a list.
-   `prop(x, "name")` and `prop(x, "name") <- value` set a property using a string name.
-   `prop_exists(x, "name")` tells you if a property exists.

