---
title: "R7"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{R7}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(R7)
```

## Classes and objects

```{r}
range <- new_class("range",
  validator = function(self) {
    if (self@end < self@start) {
      "<range>@end must be greater than or equal to <range>@start"
    }
  },
  properties = list(
    start = "numeric",
    end = "numeric",
    new_property(
      name = "length",
      class = "numeric",
      getter = function(x) x@end - x@start,
      setter = function(x, value) {
        x@end <- x@start + value
        x
      }
    )
  )
)

x <- range(start = 1, end = 10)

x@start

x@end

x@length

x@length <- 5

x@length
```

```{r error = TRUE}
# incorrect properties throws an error
x@middle

# assigning properties verifies the class matches the class of the value
x@end <- "foo"

# assigning properties runs the validator
x@end <- 0
```

```{r}
# Print methods for both R7_class objects
range

# As well as normal R7_objects
x
```

## Generics and methods

```{r}
text <- new_class("text", parent = "character")
foo <- new_generic("foo", "x")
method(foo, text) <- function(x, ...) paste0("foo-", x)

foo(text("hi"))
```

## Multiple dispatch

Multiple dispatch uses a table stored in the `methods` property of the generic.
This table is a nested set of hashed environments based on the classes of the methods.
e.g.

For `method(foo, c("character", "numeric"))` the method would be stored at `foo@methods[["character"]][["numeric"]]`.

At each level the search iteratively searches along objects class vector.

```{r}
bar <- new_generic("bar", c("x", "y"))
method(bar, list("character", "double")) <- function(x, y) paste0("foo-", x, ":", y)

bar("hi", 42)
```

## Calling the next method

`next_method()` is used to call the next method for the arguments.
This works by looking up the call stack and retrieving R7 methods which have already been called, then doing a method search with those methods excluded.
This ensures you cannot call the same method twice.

```{r}
method(bar, list(text, "double")) <- function(x, y, ...) {
  res <- next_method()(x, y)
  paste0("2 ", res)
}

bar(text("hi"), 42)
```

## Non-standard evaluation

`method_call()` retains promises for dispatch arguments in basically the same way as `UseMethod()`, so non-standard evaluation works basically the same as S3.

```{r}
subset2 <- new_generic("subset2", "x")

method(subset2, new_S3_class("data.frame")) <- function(x, subset = NULL, select = NULL, drop = FALSE) {
  e <- substitute(subset)
  # Unlike S3, R7 creates a frame for the generic, so we need to
  # go one extra level up to get to the user's evaluation environment
  r <- eval(e, x, parent.frame(2))
  r <- r & !is.na(r)
  nl <- as.list(seq_along(x))
  names(nl) <- names(x)
  vars <- eval(substitute(select), nl, parent.frame())
  x[r, vars, drop = drop]
}

subset2(mtcars, hp > 200, c(wt, qsec))
```

### External generics

If you want to define methods for R7 generics defined in another package you can use `new_extrenal_generic` to declare the external generic, then add `R7::external_methods_register()` to the `.onLoad` function in your package.
`external_methods_register()` will automatically setup on-load hooks for 'soft' dependencies in `Suggests` so the method will be added when the dependency is eventually loaded.

```{r eval = FALSE}
.onLoad <- function(libname, pkgname) {
  R7::external_methods_register()
}

foo <- new_external_generic("pkg1", "foo")
method(foo, "integer") <- function(x) paste0("foo-", x)
```
