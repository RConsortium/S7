% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convert.R
\name{convert}
\alias{convert}
\title{Convert an object from one type to another}
\usage{
convert(from, to, ...)
}
\arguments{
\item{from}{An S7 object to convert.}

\item{to}{An S7 class specification, passed to \code{\link[=as_class]{as_class()}}.}

\item{...}{Other arguments passed to custom \code{convert()} methods.}
}
\description{
\code{convert()} uses double-dispatch, because conversion depends on both \code{from}
and \code{to}. The dispatch is non-standard, because \code{to} is a class (not an
object), and it does not take advantage of inheritance (because if you
convert \code{x} to \code{superFoo} you shouldn't get an instance of \code{Foo} back).

\code{convert()} provides built-in implementations if \code{from} inherits from \code{to}.
This default strips any properties that \code{from} possesses that \code{to} does not,
and resets the class.
}
\examples{
foo1 <- new_class("foo1", properties = list(x = class_integer))
foo2 <- new_class("foo2", foo1, properties = list(y = class_double))

method(convert, list(foo1, class_integer)) <- function(from, to) from@x
method(convert, list(foo2, class_double)) <- function(from, to) from@y

convert(foo1(x = 1L), to = class_integer)
try(convert(foo1(x = 1L), to = class_double))

convert(foo2(x = 1L, y = 2), to = class_integer)
convert(foo2(x = 1L, y = 2), to = class_double)
convert(foo2(x = 1L, y = 2), to = foo1)

# If we define a convert method for integer + foo1:
method(convert, list(class_integer, foo1)) <- function(from, to) foo1(x = from)
convert(1L, to = foo1)
# Converting too foo2 still errors
try(convert(1L, to = foo2))
}
