% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cast.R
\name{cast_next}
\alias{cast_next}
\title{Force next method dispatch to use a superclass}
\usage{
cast_next(from, to = NULL)
}
\arguments{
\item{from}{An R7 object to cast.}

\item{to}{An R7 class specification, passed to \code{\link[=as_class]{as_class()}}. Must be a
superclass of \code{object}. If not specified, defaults to the parent of
\code{from}.}
}
\value{
An \code{R7_cast_next} object which should always be passed
immediately to a generic. It has no other special behavior.
}
\description{
\code{cast_next()} is a variant of \code{cast()} that only affects the next method
dispatch. It is useful when you want to re-call a generic, forcing method
dispatch to find an implementation for a superclass.
}
\section{Compared to S3 and S4}{
\code{cast_next()} performs a similar role to \code{\link[=NextMethod]{NextMethod()}} in S3 or
\code{\link[methods:NextMethod]{methods::callNextMethod()}} in S4. It has two main differences:
\itemize{
\item It casts to a class that is known at definiton-time.
\item You must manually pass along all of the arguments.
}

This makes \code{cast_next()} more verbose, but substantially easier to reason
about. It also avoids some of the dynamism of \code{NextMethod()}: registering
methods for a parent class can not method dispatch for a child class.
}

\examples{
foo1 <- new_class("foo1", properties = list(x = "numeric", y = "numeric"))
foo2 <- new_class("foo2", foo1, properties = list(z = "numeric"))

total <- new_generic("total", "x")
method(total, foo1) <- function(x) x@x + x@y

# This doesn't work because it'll be stuck in an infinite loop:
method(total, foo2) <- function(x) total(x) + x@z

# This ensures the nested total calls the parent method
method(total, foo2) <- function(x) total(cast_next(x)) + x@z

total(foo2(1, 2, 3))
}
