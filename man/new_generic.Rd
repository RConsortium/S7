% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic.R, R/dispatch.R
\name{new_generic}
\alias{new_generic}
\alias{method_call}
\title{Define a new generic}
\usage{
new_generic(name, fun = NULL, dispatch_args = NULL)

method_call()
}
\arguments{
\item{name}{The name of the generic. This should be the same as the object
that you assign it to.}

\item{fun}{An optional specification of the generic, which must call
\code{method_call()} to dispatch to methods. This is usually generated
automatically from the \code{dispatch_args}, but you may want to supply it if
you want to add additional required arguments, or perform some standardised
computation in the generic.}

\item{dispatch_args}{A character vector giving the names of the arguments
that form the signature, i.e. the arguments used for method dispatch.

If \code{dispatch_args} are omitted, but \code{fun} is supplied, will default to the
arguments that appear before \code{...} in \code{fun}. If there are no dots, it will
default to the first argument. If both \code{fun} and \code{dispatch_args} are
supplied, the \code{dispatch_args} must appear at the start of \code{fun}'s formals.}
}
\description{
A generic function uses different implementations (\emph{methods}) depending on
the class of one or more arguments (the \emph{signature}). Create a new generic
with \code{new_generic()} then use \link{method<-} to add methods to it. The body of
the generic always contains \code{method_call()}, which takes care of finding and
calling the appropriate method.
}
\section{Dispatch arguments}{

The arguments that are used to pick the method are called the \strong{dispatch
arguments}. In most cases, this will be one argument, in which case the
generic is said to use \strong{single dispatch}. If it consists of more than
one argument, it's said to use \strong{multiple dispatch}.

There are two restrictions on the dispatch arguments: they must be the first
arguments to the generic and if the generic uses \code{...}, it must occur
immediately after the dispatch arguments.
}

\examples{
# A simple generic with methods for some base types and S3 classes
type_of <- new_generic("type_of", dispatch_args = "x")
method(type_of, "character") <- function(x, ...) "A character vector"
method(type_of, s3_class("data.frame")) <- function(x, ...) "A data frame"
method(type_of, "function") <- function(x, ...) "A function"

type_of(mtcars)
type_of(letters)
type_of(mean)

# If you want to require methods implement additional arguments, supply
# them after ... in the call
mean2 <- new_generic("mean2", function(x, ..., na.rm = TRUE) {
   method_call()
})
method(mean2, "numeric") <- function(x, ..., na.rm = TRUE) {
  if (na.rm) {
    x <- x[!is.na(x)]
  }
  sum(x) / length(x)
}
method(mean2, "character") <- function(x, ..., na.rm = TRUE) {
  stop("Not supported")
}

}
\seealso{
\code{\link[=new_external_generic]{new_external_generic()}} to define a method for a generic
in another package without taking a strong dependency on it.
}
